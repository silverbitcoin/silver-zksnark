//! Testnet deployment and testing utilities
//!
//! This module provides tools for deploying and testing zk-SNARK
//! implementation on testnet validators.

use crate::error::{Result, ZkSnarkError};
use crate::types::Proof;
use crate::consensus::ProvenSnapshot;
use tracing::{info, warn, error};
use std::collections::HashMap;

/// Testnet validator configuration
#[derive(Debug, Clone)]
pub struct TestnetValidator {
    /// Validator ID
    pub id: String,
    
    /// Validator address
    pub address: Vec<u8>,
    
    /// Whether validator is active
    pub active: bool,
    
    /// Proofs generated by this validator
    pub proofs_generated: u64,
    
    /// Proofs verified by this validator
    pub proofs_verified: u64,
    
    /// Average proof generation time (ms)
    pub avg_generation_time_ms: u64,
    
    /// Average proof verification time (ms)
    pub avg_verification_time_ms: u64,
}

impl TestnetValidator {
    /// Create a new testnet validator
    pub fn new(id: String, address: Vec<u8>) -> Self {
        Self {
            id,
            address,
            active: true,
            proofs_generated: 0,
            proofs_verified: 0,
            avg_generation_time_ms: 0,
            avg_verification_time_ms: 0,
        }
    }

    /// Record a proof generation
    pub fn record_generation(&mut self, time_ms: u64) {
        self.proofs_generated += 1;
        self.avg_generation_time_ms = 
            (self.avg_generation_time_ms + time_ms) / 2;
    }

    /// Record a proof verification
    pub fn record_verification(&mut self, time_ms: u64) {
        self.proofs_verified += 1;
        self.avg_verification_time_ms = 
            (self.avg_verification_time_ms + time_ms) / 2;
    }

    /// Get validator statistics
    pub fn stats(&self) -> ValidatorStats {
        ValidatorStats {
            id: self.id.clone(),
            proofs_generated: self.proofs_generated,
            proofs_verified: self.proofs_verified,
            avg_generation_time_ms: self.avg_generation_time_ms,
            avg_verification_time_ms: self.avg_verification_time_ms,
        }
    }
}

/// Validator statistics
#[derive(Debug, Clone)]
pub struct ValidatorStats {
    pub id: String,
    pub proofs_generated: u64,
    pub proofs_verified: u64,
    pub avg_generation_time_ms: u64,
    pub avg_verification_time_ms: u64,
}

/// Testnet network
pub struct TestnetNetwork {
    /// Validators
    validators: HashMap<String, TestnetValidator>,
    
    /// Snapshots
    snapshots: Vec<ProvenSnapshot>,
    
    /// Network statistics
    stats: NetworkStats,
}

/// Network statistics
#[derive(Debug, Clone)]
pub struct NetworkStats {
    /// Total snapshots processed
    pub total_snapshots: u64,
    
    /// Total proofs generated
    pub total_proofs: u64,
    
    /// Average block time (ms)
    pub avg_block_time_ms: u64,
    
    /// Network throughput (TPS)
    pub throughput_tps: u64,
    
    /// Network uptime (%)
    pub uptime_percent: f64,
}

impl Default for NetworkStats {
    fn default() -> Self {
        Self {
            total_snapshots: 0,
            total_proofs: 0,
            avg_block_time_ms: 480,
            throughput_tps: 0,
            uptime_percent: 100.0,
        }
    }
}

impl TestnetNetwork {
    /// Create a new testnet network
    pub fn new() -> Self {
        info!("Initializing testnet network");
        
        Self {
            validators: HashMap::new(),
            snapshots: Vec::new(),
            stats: NetworkStats::default(),
        }
    }

    /// Add a validator to the network
    pub fn add_validator(&mut self, validator: TestnetValidator) -> Result<()> {
        if self.validators.contains_key(&validator.id) {
            return Err(ZkSnarkError::ProofGenerationFailed(
                format!("Validator {} already exists", validator.id)
            ));
        }

        info!("Adding validator to testnet: {}", validator.id);
        self.validators.insert(validator.id.clone(), validator);
        Ok(())
    }

    /// Get a validator
    pub fn get_validator(&self, id: &str) -> Option<&TestnetValidator> {
        self.validators.get(id)
    }

    /// Get a mutable validator
    pub fn get_validator_mut(&mut self, id: &str) -> Option<&mut TestnetValidator> {
        self.validators.get_mut(id)
    }

    /// Add a snapshot to the network
    pub fn add_snapshot(&mut self, snapshot: ProvenSnapshot) -> Result<()> {
        info!("Adding snapshot {} to testnet", snapshot.snapshot_number);
        
        self.snapshots.push(snapshot);
        self.stats.total_snapshots += 1;
        self.stats.total_proofs += 1;
        
        Ok(())
    }

    /// Get network statistics
    pub fn stats(&self) -> &NetworkStats {
        &self.stats
    }

    /// Get validator statistics
    pub fn validator_stats(&self) -> Vec<ValidatorStats> {
        self.validators.values().map(|v| v.stats()).collect()
    }

    /// Get number of active validators
    pub fn active_validators(&self) -> usize {
        self.validators.values().filter(|v| v.active).count()
    }

    /// Get total snapshots
    pub fn snapshot_count(&self) -> usize {
        self.snapshots.len()
    }

    /// Calculate network health
    pub fn health_check(&self) -> Result<NetworkHealth> {
        let active_validators = self.active_validators();
        let total_validators = self.validators.len();
        
        if active_validators < (total_validators * 2 / 3) {
            warn!("Network health degraded: {} active validators", active_validators);
        }

        let health = NetworkHealth {
            active_validators,
            total_validators,
            snapshots_processed: self.snapshots.len(),
            avg_generation_time_ms: self.stats.avg_block_time_ms,
            network_healthy: active_validators >= (total_validators * 2 / 3),
        };

        Ok(health)
    }
}

impl Default for TestnetNetwork {
    fn default() -> Self {
        Self::new()
    }
}

/// Network health status
#[derive(Debug, Clone)]
pub struct NetworkHealth {
    pub active_validators: usize,
    pub total_validators: usize,
    pub snapshots_processed: usize,
    pub avg_generation_time_ms: u64,
    pub network_healthy: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validator_creation() {
        let validator = TestnetValidator::new(
            "validator1".to_string(),
            vec![1u8; 32],
        );
        assert_eq!(validator.id, "validator1");
        assert!(validator.active);
    }

    #[test]
    fn test_validator_stats() {
        let mut validator = TestnetValidator::new(
            "validator1".to_string(),
            vec![1u8; 32],
        );
        
        validator.record_generation(100);
        validator.record_generation(200);
        
        let stats = validator.stats();
        assert_eq!(stats.proofs_generated, 2);
    }

    #[test]
    fn test_testnet_network_creation() {
        let network = TestnetNetwork::new();
        assert_eq!(network.active_validators(), 0);
    }

    #[test]
    fn test_add_validator() {
        let mut network = TestnetNetwork::new();
        let validator = TestnetValidator::new(
            "validator1".to_string(),
            vec![1u8; 32],
        );
        
        let result = network.add_validator(validator);
        assert!(result.is_ok());
        assert_eq!(network.active_validators(), 1);
    }

    #[test]
    fn test_duplicate_validator() {
        let mut network = TestnetNetwork::new();
        let validator1 = TestnetValidator::new(
            "validator1".to_string(),
            vec![1u8; 32],
        );
        let validator2 = TestnetValidator::new(
            "validator1".to_string(),
            vec![2u8; 32],
        );
        
        network.add_validator(validator1).unwrap();
        let result = network.add_validator(validator2);
        assert!(result.is_err());
    }

    #[test]
    fn test_network_health() {
        let mut network = TestnetNetwork::new();
        
        for i in 0..3 {
            let validator = TestnetValidator::new(
                format!("validator{}", i),
                vec![i as u8; 32],
            );
            network.add_validator(validator).unwrap();
        }
        
        let health = network.health_check().unwrap();
        assert_eq!(health.active_validators, 3);
        assert!(health.network_healthy);
    }
}
